#include <iostream>
#include <stack>
#include <string>
#include <queue>
#include <windows.h>

using namespace std;

char zam(char a)	// Изменение направления скобки
{
	char b;
	if (a == '(') b = ')';
	if (a == '{') b = '}';
	if (a == '[') b = ']';

	if (a == ')') b = '(';
	if (a == '}') b = '{';
	if (a == ']') b = '[';

	return b;
}
void Change_Direction_Of_Brackets(string str, char* str1) // Меняем открытые скобки на закрытые и наоборот
{
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '(') str1[i] = ')';
		else if (str[i] == '[') str1[i] = ']';
		else if (str[i] == '{') str1[i] = '}';

		else if (str[i] == ')') str1[i] = '(';
		else if (str[i] == ']') str1[i] = '[';
		else if (str[i] == '}') str1[i] = '{';

		else str1[i] = str[i];
	}
}
bool Number_Of_Brackets_is_Even(string str) // Проверка на чётность скобок
{
	int count = 0;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '{' || str[i] == '(' || str[i] == '[' || str[i] == '}' || str[i] == ')' || str[i] == ']') ++count;
	}

	if (count % 2 == 0) return true; // Если количество скобок в строке чётно
	else return false;
}
void fill(char* str, int size)		// Заполнение строки
{
	for (int i = 0; i < size; i++)
	{
		str[i] = 'x';
	}
}

int main()
{
	setlocale(LC_ALL, "ru"); HANDLE color = GetStdHandle(STD_OUTPUT_HANDLE);

	stack<char> st; stack<int> gap;
	string str{ "({[)]}[)" };
	int sznewstr = str.size() * 2; char* newstr = new char[sznewstr];
	int szstr1 = str.size(); char* str1 = new char[szstr1];

	if (!Number_Of_Brackets_is_Even(str))
	{
		cout << "Скобок в строке нечётное количество." << endl;
		return 0;
	}

	fill(newstr, sznewstr);						// Инициализируем новую строку
	Change_Direction_Of_Brackets(str, str1);	// Изменяем направление скобок строки str


	int j = 0;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '(' || str[i] == '{' || str[i] == '[')			// Если встречается открытая скобка в строке - помещаем её в стэк
		{
			st.emplace(str[i]);						// Добавляем в стэк открытую скобку
			newstr[j++] = str[i];					// Добавляем скобку в новую строку
			newstr[j++] = ' '; gap.emplace(j - 1);	// Добавляем после скобки пробел в новую строку и сохраняем индекс пробела
		}
		else if (str[i] == ')' || str[i] == '}' || str[i] == ']')		// Если встречается закрытая скобка в строке - проверяем её с последним элементом в стэке
		{
			if (str1[i] == st.top())				// Если равны, то открытая и закрытая скобка совпадает, удаляем последний элемент из стэка
			{
				newstr[j++] = str[i];
				st.pop(); gap.pop();
			}
			else									// Если не равны, то 
			{
				newstr[gap.top()] = zam(str[i]);
				newstr[j++] = str[i]; 
				newstr[j++] = zam(st.top());
				st.pop(); gap.pop();
			}
		}
	}
	



	sznewstr = j;
	for (int i = 0; i < sznewstr; i++)
	{
		SetConsoleTextAttribute(color, FOREGROUND_BLUE);
		if (newstr[i] == '(' || newstr[i] == ')') cout << newstr[i];

		SetConsoleTextAttribute(color, FOREGROUND_GREEN);
		if (newstr[i] == '{' || newstr[i] == '}') cout << newstr[i];

		SetConsoleTextAttribute(color, FOREGROUND_RED);
		if (newstr[i] == '[' || newstr[i] == ']') cout << newstr[i];
	}
	SetConsoleTextAttribute(color, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);
	cout << endl;

	delete[] newstr;

	return 0;
}