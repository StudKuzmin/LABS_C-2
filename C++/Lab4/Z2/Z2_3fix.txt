#include <iostream>
#include <stack>
#include <string>
#include <queue>
#include <windows.h>

using namespace std;

char zam(char a)	// Изменение направления скобки
{
	char b;
	if (a == '(') b = ')';
	if (a == '{') b = '}';
	if (a == '[') b = ']';

	if (a == ')') b = '(';
	if (a == '}') b = '{';
	if (a == ']') b = '[';

	return b;
}
void Change_Direction_Of_Brackets(string str, char* str1) // Меняем открытые скобки на закрытые и наоборот
{
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '(') str1[i] = ')';
		else if (str[i] == '[') str1[i] = ']';
		else if (str[i] == '{') str1[i] = '}';

		else if (str[i] == ')') str1[i] = '(';
		else if (str[i] == ']') str1[i] = '[';
		else if (str[i] == '}') str1[i] = '{';

		else str1[i] = str[i];
	}
}
bool First_Bracket_is_Closed(string str) // Проверка на направление первой скобки
{
	int count = 0;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == ')' || str[i] == '}' || str[i] == ']') return true;
		else if (str[i] == '(' || str[i] == '{' || str[i] == '[') return false;
	}
}
void fill(char* str, int size)		// Заполнение строки
{
	for (int i = 0; i < size; i++)
	{
		str[i] = 'x';
	}
}

int main()
{
	setlocale(LC_ALL, "ru"); HANDLE color = GetStdHandle(STD_OUTPUT_HANDLE);

	stack<char> st;
	string str{ "([x + y}*2 + {3 - x*[z*y)" };
	int sznewstr = str.size() * 2; char* newstr = new char[sznewstr];
	int szstr1 = str.size(); char* str1 = new char[szstr1];

	
	if (First_Bracket_is_Closed(str))			// Проверка на направление первой скобки
	{
		cout << "Операция не может начинаться с закрытой скобки." << endl;

		return 0;
	}
	fill(newstr, sznewstr);						// Инициализируем новую строку
	Change_Direction_Of_Brackets(str, str1);	// Изменяем направление скобок строки str


	int j = 0; bool end = false;
	for (int i = 0; i < str.size(); i++)
	{
		if (str[i] == '(' || str[i] == '{' || str[i] == '[')			// Если встречается открытая скобка в строке - помещаем её в стэк
		{
			st.emplace(str[i]);						// Добавляем в стэк открытую скобку
			newstr[j++] = str[i];					// Добавляем скобку в новую строку
		}
		else if (str[i] == ')' || str[i] == '}' || str[i] == ']')		// Если встречается закрытая скобка в строке - проверяем её с последним элементом в стэке
		{
			if (str1[i] == st.top())				// Если равны, то открытая и закрытая скобка совпадает, удаляем последний элемент из стэка
			{
				newstr[j++] = str[i];
				st.pop();
			}
			else									// Если не равны, то 
			{
				newstr[j++] = zam(st.top());
				st.pop();
			}
		}
		else newstr[j++] = str[i];
	}
	while (!st.empty())
	{
		newstr[j++] = zam(st.top());
		st.pop();
	}



	sznewstr = j;
	for (int i = 0; i < sznewstr; i++)
	{
		SetConsoleTextAttribute(color, FOREGROUND_BLUE);
		if (newstr[i] == '(' || newstr[i] == ')')
		{
			cout << newstr[i];
			continue;
		}

		SetConsoleTextAttribute(color, FOREGROUND_GREEN);
		if (newstr[i] == '{' || newstr[i] == '}') 
		{
			cout << newstr[i];
			continue;
		}

		SetConsoleTextAttribute(color, FOREGROUND_RED);
		if (newstr[i] == '[' || newstr[i] == ']') 
		{
			cout << newstr[i];
			continue;
		}

		SetConsoleTextAttribute(color, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);
		cout << newstr[i];
		
	}
	SetConsoleTextAttribute(color, FOREGROUND_RED | FOREGROUND_BLUE | FOREGROUND_GREEN);
	cout << endl;

	delete[] newstr;

	return 0;
}